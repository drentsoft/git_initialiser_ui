extends Node

signal output

enum Cleanup{NO_CLEAN, CLEAN_NON_EMPTY, FORCE_CLEAN}

const DEFAULT_VCS = ".git"

var root_dir : String = ""

var vcs_dir : String = ".git"
var cleanup : int = Cleanup.NO_CLEAN

var placeholder_filename : String = ".deleteme"
var write_placeholder_text : bool = false
var placeholder_content = """This file has been generated by Drentsoft Git Initialiser (GI for short).
Please do not delete this file until there are tracked files in this directory or directories that are children of this one.
This file will be removed by GI when running a clean operation if there are other files in this directory (tracked or not) or if the force clean mode is used."""

func check_for_child_directories(path: String) -> void:
	var split = path.split("/")
	if split.size() > 0 and split[split.size()-1].nocasecmp_to(vcs_dir) == 0:
		# skip
		add_output("[color=yellow]Ignoring VCS directory[/color] %s" % path)
		return
	add_output("[color=green]Scanning folder[/color] %s" % path)
	var children : int = 0
	var dir = Directory.new()
	var err = dir.open(path)
	if err == OK:
		var file_list = []
		var dirs_to_check = []
		dir.list_dir_begin(true)
		var file = dir.get_next()
		while(file != ""):
			file_list.append(file)
			if dir.current_is_dir():
				dirs_to_check.append(file)
			file = dir.get_next()
		dir.list_dir_end()
		if file_list.size() == 0:
			if cleanup == Cleanup.NO_CLEAN:
				# Add file 
				create_placeholder_file(path)
			else:
				pass#add_output("[color=blue]No children, ignoring for cleanup[/color]")
		else:
			if cleanup > Cleanup.NO_CLEAN:
				if file_list.size() == 1 and file_list.has(placeholder_filename):
					add_output("[color=#FF9900]%s is still empty.[/color]" % path)
					if cleanup == Cleanup.FORCE_CLEAN:
						clean_dir(path, true)
				else:
					#add_output("[color=green]Not empty, checking for placeholder file...[/color]")
					clean_dir(path) # More than just the placeholder file in the directory, we can clean it
		for child in dirs_to_check:
			print(child)
			check_for_child_directories(path + "/" + child)
	else:
		add_output("Error %s opening directory %s" % [err, path])

func create_placeholder_file(dir : String) -> bool:
	add_output("%s needs a placeholder file" % dir)
	var file = File.new()
	var f_name = dir + "/" + placeholder_filename
	var err = file.open(f_name, File.WRITE)
	if err == OK:
		add_output("[color=green]Creating placeholder file[/color] %s [color=green]in[/color] %s" % [placeholder_filename, dir])
		if write_placeholder_text:
			file.store_string(placeholder_content)
		else:
			file.store_string("")
		file.close()
		return true
	else:
		add_output("[color=red]Error %s creating placeholder file[/color]" % err)
		return false

func remove_placeholder_file(dir : String) -> bool:
	return false

func clean_dir(path: String, force: bool = false) -> void:
	print("Cleaning " + path)
	var dir = Directory.new()
	var err = dir.open(path)
	if err == OK:
		if !dir.file_exists(placeholder_filename):
			add_output("[color=#FF9900]No placeholder file found. Ignoring directory[/color]")
			return
		if force:
			add_output("[color=#FF9900]Removing file anyway. Force clean option used.[/color]")
		err = dir.remove(placeholder_filename)
		if err == OK:
			add_output("[color=green]Removed placeholder from %s[/color]" % path)
		else:
			add_output("[color=red]Failed to remove placeholder from %s[/color]" % path)
	else:
		add_output("[color=red]Can't open %s for cleanup[/color]" % path)

func add_output(msg: String) -> void:
	#print(msg.replace("\[(\w+).*?\].*?\[/\1\]", "")
	emit_signal("output", msg)